
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Mem_Synth(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output	reg	     [6:0]		HEX0,
	output	reg	     [6:0]		HEX1,
	output	reg	     [6:0]		HEX2,
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,
	output	reg	     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);


parameter HEX_0 = 7'b1000000;		// zero
parameter HEX_1 = 7'b1111001;		// one
parameter HEX_2 = 7'b0100100;		// two
parameter HEX_3 = 7'b0110000;		// three
parameter HEX_4 = 7'b0011001;		// four
parameter HEX_5 = 7'b0010010;		// five
parameter HEX_6 = 7'b0000010;		// six
parameter HEX_7 = 7'b1111000;		// seven
parameter HEX_8 = 7'b0000000;		// eight
parameter HEX_9 = 7'b0011000;		// nine
parameter HEX_10 = 7'b0001000;	// ten
parameter HEX_11 = 7'b0000011;	// eleven
parameter HEX_12 = 7'b1000110;	// twelve
parameter HEX_13 = 7'b0100001;	// thirteen
parameter HEX_14 = 7'b0000110;	// fourteen
parameter HEX_15 = 7'b0001110;	// fifteen
parameter OFF   = 7'b1111111;		// all off


//=======================================================
//  REG/WIRE declarations
//=======================================================
wire rst_n, clk, start_addr, end_addr, rden;
reg start_addr_reg, rden_reg, end_addr_reg;
reg [1:0] key1debounce, start_count, end_count;
reg [31:0] addr, count;
reg [9:0] delay_count;
wire [31:0] data;




//=======================================================
//  Module Instantiation
//=======================================================
mem idut (
	.clk(CLOCK_50),
    .rst_n(rst_n),
    .read_en(rden),
    .addr(addr),
    .q(data)
);

//=======================================================
//  Structural coding
//=======================================================
assign clk = CLOCK_50;
assign rst_n = KEY[0]; //already active low

always @(posedge clk) begin
	if(!rst_n) begin
		start_addr_reg <= 1'b0;
	end else if(key1debounce[1] & ~key1debounce[0]) begin
		start_addr_reg <= 1'b1;
		rden_reg <= 1'b1; //
	end
end

always @(posedge clk) begin
	if(!rst_n) begin
		end_addr_reg <= 1'b0;
	end else if((addr == 32'd8192)) begin
		end_addr_reg <= 1'b1;
		rden_reg <= 1'b0;
	end
end

always @(posedge clk) begin
	if(!rst_n) begin
		key1debounce <= 2'b00;
	end
	else begin
		key1debounce[0] <= KEY[1];
		key1debounce[1] <= key1debounce[0];
	end
end 

assign start_addr = start_addr_reg;
assign end_addr = end_addr_reg;
assign rden = 1'b1;

//Delay for mem
always @(posedge clk) begin
	if (!rst_n) begin
		start_count <= 2'b00;
		end_count <= 2'b00;
	end else begin
		start_count[0] <= start_addr;
		end_count[0] <= end_addr;
		start_count[1] <= start_count[0];
		end_count[1] <= end_count[0];		
	end
end

//Value calculator (should see 2048 on the 7seg in hex)
always @(posedge clk) begin
	if(!rst_n) begin
		count <= 32'h0;
	end
	else if(end_count[1]) begin
		count <= count;
	end
	else if(start_count[1] && (data != 32'b0)) begin
		count <= (data == 32'hFFFFFFFF) ? count + 1 : count;
	end
	else begin
		count <= count;
	end
end

//Address counter
always @(posedge clk) begin
	if(!rst_n) begin
		addr <= 32'h0;
		rden_reg <= 1'b0;
	end
	else if(end_count) begin
		addr <= addr;
		rden_reg <= 1'b0; 
	end
	else if(start_count) begin
		addr <= addr + 4'h4;

	end
	else begin
		addr <= addr;
	end
end

//Delay calculator
always @(posedge clk) begin
	if(!rst_n) begin
		delay_count <= 10'h0;
	end else if(rden & (data == 32'h0)) begin
		delay_count <= delay_count + 1'b1;
	end
end

assign LEDR = delay_count;


always @(*) begin
	if (1'b1) begin
	  case(count[3:0])
		4'd0: HEX0 = HEX_0;
		 4'd1: HEX0 = HEX_1;
		 4'd2: HEX0 = HEX_2;
		 4'd3: HEX0 = HEX_3;
		 4'd4: HEX0 = HEX_4;
		 4'd5: HEX0 = HEX_5;
		 4'd6: HEX0 = HEX_6;
		 4'd7: HEX0 = HEX_7;
		 4'd8: HEX0 = HEX_8;
		 4'd9: HEX0 = HEX_9;
		 4'd10: HEX0 = HEX_10;
		 4'd11: HEX0 = HEX_11;
		 4'd12: HEX0 = HEX_12;
		 4'd13: HEX0 = HEX_13;
		 4'd14: HEX0 = HEX_14;
		 4'd15: HEX0 = HEX_15;
	  endcase
	end
	else begin
	  HEX0 = OFF;
	end
  end
  
  always @(*) begin
	if (1'b1) begin
	  case(count[7:4])
		4'd0: HEX1 = HEX_0;
		 4'd1: HEX1 = HEX_1;
		 4'd2: HEX1 = HEX_2;
		 4'd3: HEX1 = HEX_3;
		 4'd4: HEX1 = HEX_4;
		 4'd5: HEX1 = HEX_5;
		 4'd6: HEX1 = HEX_6;
		 4'd7: HEX1 = HEX_7;
		 4'd8: HEX1 = HEX_8;
		 4'd9: HEX1 = HEX_9;
		 4'd10: HEX1 = HEX_10;
		 4'd11: HEX1 = HEX_11;
		 4'd12: HEX1 = HEX_12;
		 4'd13: HEX1 = HEX_13;
		 4'd14: HEX1 = HEX_14;
		 4'd15: HEX1 = HEX_15;
	  endcase
	end
	else begin
	  HEX1 = OFF;
	end
  end
  
  always @(*) begin
	if (1'b1) begin
	  case(count[11:8])
		4'd0: HEX2 = HEX_0;
		 4'd1: HEX2 = HEX_1;
		 4'd2: HEX2 = HEX_2;
		 4'd3: HEX2 = HEX_3;
		 4'd4: HEX2 = HEX_4;
		 4'd5: HEX2 = HEX_5;
		 4'd6: HEX2 = HEX_6;
		 4'd7: HEX2 = HEX_7;
		 4'd8: HEX2 = HEX_8;
		 4'd9: HEX2 = HEX_9;
		 4'd10: HEX2 = HEX_10;
		 4'd11: HEX2 = HEX_11;
		 4'd12: HEX2 = HEX_12;
		 4'd13: HEX2 = HEX_13;
		 4'd14: HEX2 = HEX_14;
		 4'd15: HEX2 = HEX_15;
	  endcase
	end
	else begin
	  HEX2 = OFF;
	end
  end
  
  always @(*) begin
	if (1'b1) begin
	  case(count[15:12])
		4'd0: HEX3 = HEX_0;
		 4'd1: HEX3 = HEX_1;
		 4'd2: HEX3 = HEX_2;
		 4'd3: HEX3 = HEX_3;
		 4'd4: HEX3 = HEX_4;
		 4'd5: HEX3 = HEX_5;
		 4'd6: HEX3 = HEX_6;
		 4'd7: HEX3 = HEX_7;
		 4'd8: HEX3 = HEX_8;
		 4'd9: HEX3 = HEX_9;
		 4'd10: HEX3 = HEX_10;
		 4'd11: HEX3 = HEX_11;
		 4'd12: HEX3 = HEX_12;
		 4'd13: HEX3 = HEX_13;
		 4'd14: HEX3 = HEX_14;
		 4'd15: HEX3 = HEX_15;
	  endcase
	end
	else begin
	  HEX3 = OFF;
	end
  end
  
  always @(*) begin
	if (1'b1) begin
	  case(count[19:16])
		4'd0: HEX4 = HEX_0;
		 4'd1: HEX4 = HEX_1;
		 4'd2: HEX4 = HEX_2;
		 4'd3: HEX4 = HEX_3;
		 4'd4: HEX4 = HEX_4;
		 4'd5: HEX4 = HEX_5;
		 4'd6: HEX4 = HEX_6;
		 4'd7: HEX4 = HEX_7;
		 4'd8: HEX4 = HEX_8;
		 4'd9: HEX4 = HEX_9;
		 4'd10: HEX4 = HEX_10;
		 4'd11: HEX4 = HEX_11;
		 4'd12: HEX4 = HEX_12;
		 4'd13: HEX4 = HEX_13;
		 4'd14: HEX4 = HEX_14;
		 4'd15: HEX4 = HEX_15;
	  endcase
	end
	else begin
	  HEX4 = OFF;
	end
  end
  
  always @(*) begin
	if (1'b1) begin
	  case(count[23:20])
		4'd0: HEX5 = HEX_0;
		 4'd1: HEX5 = HEX_1;
		 4'd2: HEX5 = HEX_2;
		 4'd3: HEX5 = HEX_3;
		 4'd4: HEX5 = HEX_4;
		 4'd5: HEX5 = HEX_5;
		 4'd6: HEX5 = HEX_6;
		 4'd7: HEX5 = HEX_7;
		 4'd8: HEX5 = HEX_8;
		 4'd9: HEX5 = HEX_9;
		 4'd10: HEX5 = HEX_10;
		 4'd11: HEX5 = HEX_11;
		 4'd12: HEX5 = HEX_12;
		 4'd13: HEX5 = HEX_13;
		 4'd14: HEX5 = HEX_14;
		 4'd15: HEX5 = HEX_15;
	  endcase
	end
	else begin
	  HEX5 = OFF;
	end
  end





endmodule
